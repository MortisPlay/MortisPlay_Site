<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Змейка — Mortis Play</title>
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#10b981;
      --muted:#94a3b8;
      --danger:#ef4444;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, Arial, sans-serif;background:linear-gradient(180deg,var(--bg),#071021);color:#e6eef8}
    .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px}
    .card{width:100%;max-width:960px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:14px;padding:20px;box-shadow:0 10px 30px rgba(2,6,23,0.6);display:grid;grid-template-columns:1fr 320px;gap:18px}
    @media (max-width:900px){.card{grid-template-columns:1fr;max-width:420px}}

    /* Game area */
    .game-area{background:linear-gradient(180deg,#061024,#05101b);border-radius:10px;padding:12px;display:flex;align-items:center;justify-content:center}
    canvas{background:#071226;border-radius:8px;display:block;max-width:100%;height:auto}

    /* Panel */
    .panel{padding:12px;background:rgba(255,255,255,0.02);border-radius:10px}
    h1{font-size:18px;margin:4px 0 8px}
    .score{display:flex;gap:8px;align-items:center;margin-bottom:12px}
    .pill{background:rgba(255,255,255,0.03);padding:8px 12px;border-radius:999px;font-weight:600}
    .controls{display:flex;flex-direction:column;gap:8px}
    button{background:var(--accent);border:0;color:#032018;padding:10px 12px;border-radius:8px;font-weight:700;cursor:pointer}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    .small{padding:8px;font-size:14px}
    .muted{color:var(--muted);font-size:13px}
    .footer{margin-top:10px;font-size:13px;color:var(--muted)}

    label{font-size:13px;color:var(--muted)}
    input[type=range]{width:100%}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div>
        <div class="game-area">
          <canvas id="gameCanvas" width="600" height="600" aria-label="Поле игры змейка"></canvas>
        </div>
        <div style="margin-top:10px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap">
          <button id="btnRestart" class="small">Новая игра</button>
          <button id="btnPause" class="small secondary">Пауза</button>
          <button id="btnSlow" class="small secondary">Слить очки (reset highscore)</button>
        </div>
      </div>

      <aside class="panel">
        <h1>Змейка</h1>
        <div class="score">
          <div class="pill">Очки: <span id="score">0</span></div>
          <div class="pill">Лучший: <span id="best">0</span></div>
        </div>
        <div class="muted">Управление: стрелки или WASD. На мобильных — свайпы.</div>

        <div class="controls">
          <label>Скорость (такт/сек)</label>
          <input id="speedRange" type="range" min="4" max="18" value="8">
          <div style="display:flex;justify-content:space-between;font-size:13px;color:var(--muted)"><span>медленно</span><span>быстро</span></div>

          <label style="margin-top:8px">Размер сетки</label>
          <input id="gridRange" type="range" min="10" max="30" value="20">
          <div style="display:flex;justify-content:space-between;font-size:13px;color:var(--muted)"><span>мелко</span><span>крупно</span></div>

          <div style="display:flex;gap:8px">
            <button id="btnToggleGrid" class="secondary small">Показать сетку</button>
            <button id="btnTheme" class="secondary small">Тёмная/светлая</button>
          </div>
        </div>

        <div class="footer">
          <div>Инструкции: собери пищу, избегай столкновений с собой.</div>
          <div style="margin-top:8px">Могу добавить: уровни, стены, импорт очков — скажи, что нужно.</div>
        </div>
      </aside>
    </div>
  </div>

  <script>
  // ---------------------------
  // Simple Snake game (HTML + Canvas)
  // Features:
  // - Responsive canvas (scaled by CSS)
  // - Arrow keys / WASD
  // - Mobile swipe support
  // - Speed and grid size controls
  // - Score and best score stored in localStorage
  // - Pause / Restart
  // ---------------------------

  (function(){
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // UI refs
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const btnRestart = document.getElementById('btnRestart');
    const btnPause = document.getElementById('btnPause');
    const btnResetBest = document.getElementById('btnSlow');
    const speedRange = document.getElementById('speedRange');
    const gridRange = document.getElementById('gridRange');
    const btnToggleGrid = document.getElementById('btnToggleGrid');
    const btnTheme = document.getElementById('btnTheme');

    let gridSize = parseInt(gridRange.value,10); // number of cells per side
    let cell = Math.floor(canvas.width / gridSize);
    let speed = parseInt(speedRange.value,10); // ticks per second

    let snake = [];
    let dir = {x:1,y:0};
    let nextDir = {x:1,y:0};
    let food = null;
    let running = false;
    let paused = false;
    let score = 0;
    let best = parseInt(localStorage.getItem('snake_best') || '0',10) || 0;
    bestEl.textContent = best;
    let showGrid = false;

    // Timing with requestAnimationFrame and accumulator
    let lastTime = 0;
    let acc = 0;

    function reset(){
      gridSize = parseInt(gridRange.value,10);
      cell = Math.floor(canvas.width / gridSize);
      snake = [];
      const startLen = 4;
      const startX = Math.floor(gridSize/2);
      const startY = Math.floor(gridSize/2);
      for(let i=0;i<startLen;i++) snake.push({x:startX-i,y:startY});
      dir = {x:1,y:0}; nextDir = {x:1,y:0};
      placeFood();
      score = 0; scoreEl.textContent = score;
      running = true; paused = false;
      btnPause.textContent = 'Пауза';
    }

    function placeFood(){
      let tries = 0;
      while(true){
        tries++;
        if(tries>1000) break;
        const x = Math.floor(Math.random()*gridSize);
        const y = Math.floor(Math.random()*gridSize);
        if(!snake.some(s=>s.x===x && s.y===y)){
          food = {x,y};
          return;
        }
      }
      // fallback
      food = {x:0,y:0};
    }

    function tick(){
      // apply direction
      dir = nextDir;
      const head = {x:snake[0].x + dir.x, y:snake[0].y + dir.y};

      // wrap around edges
      if(head.x < 0) head.x = gridSize-1;
      if(head.y < 0) head.y = gridSize-1;
      if(head.x >= gridSize) head.x = 0;
      if(head.y >= gridSize) head.y = 0;

      // collision with self?
      if(snake.some((s,idx)=>idx>0 && s.x===head.x && s.y===head.y)){
        gameOver();
        return;
      }

      snake.unshift(head);

      // ate food?
      if(food && head.x===food.x && head.y===food.y){
        score += Math.floor(10 + speed*0.5);
        scoreEl.textContent = score;
        placeFood();
        if(score>best){
          best = score; localStorage.setItem('snake_best', String(best)); bestEl.textContent = best;
        }
      } else {
        snake.pop();
      }
    }

    function gameOver(){
      running = false;
      // simple flash
      for(let i=0;i<5;i++){
        setTimeout(()=>draw(), i*120);
      }
      setTimeout(()=>{
        alert('Игра окончена. Очки: '+score);
      }, 700);
    }

    function draw(){
      // clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // background
      ctx.fillStyle = '#071226';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // grid
      if(showGrid){
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 1;
        for(let i=0;i<=gridSize;i++){
          const p = i*cell;
          ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,canvas.height); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(canvas.width,p); ctx.stroke();
        }
      }

      // draw food
      if(food){
        const fx = food.x*cell + cell*0.12;
        const fy = food.y*cell + cell*0.12;
        const size = cell*0.76;
        ctx.fillStyle = '#ef4444';
        roundRect(ctx,fx,fy,size,size,6);
        ctx.fill();
      }

      // draw snake
      for(let i=snake.length-1;i>=0;i--){
        const s = snake[i];
        const x = s.x*cell; const y = s.y*cell;
        const radius = Math.max(2, cell*0.18);
        if(i===0){
          // head
          ctx.fillStyle = '#10b981';
          roundRect(ctx,x+1,y+1,cell-2,cell-2,Math.max(2,cell*0.15)); ctx.fill();
          // eye
          ctx.fillStyle = '#002018';
          const ex = x + cell*0.65; const ey = y + cell*0.28;
          ctx.beginPath(); ctx.arc(ex,ey,Math.max(1,cell*0.05),0,Math.PI*2); ctx.fill();
        } else {
          // body gradient
          const t = i / snake.length;
          ctx.fillStyle = `rgba(${16},${185},${129},${0.6 + 0.4*(1-t)})`;
          roundRect(ctx,x+1,y+1,cell-2,cell-2,Math.max(1,cell*0.12)); ctx.fill();
        }
      }
    }

    function roundRect(ctx,x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    // main loop
    function loop(ts){
      if(!lastTime) lastTime = ts;
      const dt = (ts - lastTime)/1000; lastTime = ts;
      acc += dt;
      const interval = 1 / Math.max(1, parseInt(speedRange.value,10)); // seconds per tick
      if(!paused && running){
        while(acc >= interval){
          tick(); acc -= interval;
        }
      }
      draw();
      requestAnimationFrame(loop);
    }

    // input
    window.addEventListener('keydown', e=>{
      const k = e.key;
      if(k==='ArrowUp' || k==='w' || k==='W') trySetDir(0,-1);
      if(k==='ArrowDown' || k==='s' || k==='S') trySetDir(0,1);
      if(k==='ArrowLeft' || k==='a' || k==='A') trySetDir(-1,0);
      if(k==='ArrowRight' || k==='d' || k==='D') trySetDir(1,0);
      if(k===' '){ paused = !paused; btnPause.textContent = paused? 'Продолжить' : 'Пауза'; }
    });

    function trySetDir(x,y){
      // prevent reversing
      if(dir.x === -x && dir.y === -y) return;
      nextDir = {x,y};
    }

    // touch: simple swipe detection
    let touchStart = null;
    canvas.addEventListener('touchstart', e=>{
      if(e.touches && e.touches[0]) touchStart = {x: e.touches[0].clientX, y: e.touches[0].clientY};
    }, {passive:true});
    canvas.addEventListener('touchend', e=>{
      if(!touchStart) return; const te = e.changedTouches[0]; const dx = te.clientX - touchStart.x; const dy = te.clientY - touchStart.y;
      if(Math.abs(dx) > Math.abs(dy)){
        if(dx>20) trySetDir(1,0); else if(dx<-20) trySetDir(-1,0);
      } else {
        if(dy>20) trySetDir(0,1); else if(dy<-20) trySetDir(0,-1);
      }
      touchStart = null;
    }, {passive:true});

    // UI handlers
    btnRestart.addEventListener('click', ()=>{ reset(); });
    btnPause.addEventListener('click', ()=>{ paused = !paused; btnPause.textContent = paused? 'Продолжить' : 'Пауза'; });
    btnResetBest.addEventListener('click', ()=>{ if(confirm('Сбросить рекорд?')){ localStorage.removeItem('snake_best'); best = 0; bestEl.textContent = best; }});

    speedRange.addEventListener('input', ()=>{ /* speed used in loop */ });
    gridRange.addEventListener('input', ()=>{ reset(); });

    btnToggleGrid.addEventListener('click', ()=>{ showGrid = !showGrid; btnToggleGrid.textContent = showGrid? 'Скрыть сетку' : 'Показать сетку'; });
    btnTheme.addEventListener('click', ()=>{
      document.documentElement.style.setProperty('--bg', getComputedStyle(document.documentElement).getPropertyValue('--bg') === '#0f1724' ? '#f8fafc' : '#0f1724');
    });

    // resize canvas to be square based on CSS size (but keep internal resolution high)
    function fitCanvas(){
      const rect = canvas.getBoundingClientRect();
      const size = Math.min(rect.width, window.innerHeight - 120);
      canvas.style.width = size + 'px';
      canvas.style.height = size + 'px';
      // keep internal resolution for crisp look
      canvas.width = Math.floor(size * devicePixelRatio);
      canvas.height = Math.floor(size * devicePixelRatio);
      // recompute cell based on internal resolution but keep grid counts
      cell = Math.floor(canvas.width / gridSize);
    }

    window.addEventListener('resize', ()=>{ fitCanvas(); draw(); });

    // start
    fitCanvas(); reset(); requestAnimationFrame(loop);

  })();
  </script>
</body>
</html>
